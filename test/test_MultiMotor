import unittest
import time
import numpy as np

from lys.Qt import QtCore
from lys_instr.dummy.MultiMotorDummy import MultiMotorDummy


class TestMultiMotorDummy(unittest.TestCase):
    """
    Unit tests for MultiMotorDummy.

    Checks correct behavior of the virtual multi-axis motor.
    """

    def test_init(self):
        """
        Tests initial state of the dummy motor.

        Checks that all axis values are zero, all axes are alive, and none are busy.
        """
        motor = MultiMotorDummy()
        self.assertTrue(all(v == 0 for v in motor.get().values()))
        self.assertTrue(all(motor.isAlive.values()))
        self.assertFalse(any(motor.isBusy.values()))


    def test_nameList(self):
        """
        Tests the nameList property.

        Checks that the nameList property returns the correct list of axis names.
        """
        motor = MultiMotorDummy('x', 'y')
        self.assertEqual(motor.nameList, ['x', 'y'])


    def test_set_get_isBusy(self):
        """
        Tests set and get methods, and busy state transitions.

        Sets target values for two axes and checks that:
        - During motion, values are between start and target, and axes are busy.
        - After motion completes, values reach targets and axes are idle.
        """
        motor = MultiMotorDummy('x', 'y')
        # motor.set(**{'x': 1, 'y': 2})
        motor.set(x=1, y=2)
        val = motor.get()
        self.assertTrue(all(0 < v < t for v, t in zip(val.values(), [1, 2])))
        self.assertTrue(all(motor.isBusy.values()))
        time.sleep(0.1 + 1/motor._speed)
        self.assertEqual([motor.isBusy['x'], motor.isBusy['y']], [False, True])
        time.sleep(0.1 + (2 - 1)/motor._speed)
        self.assertEqual([motor.isBusy['x'], motor.isBusy['y']], [False, False])
        val = motor.get()
        self.assertTrue(all(v == t for v, t in zip(val.values(), [1, 2])))


    def test_stop(self):
        """
        Tests stop method (stop during motion).

        Sets target values, waits briefly, then stops the motor.
        Checks that values have not reached targets and axes are idle after stopping.
        """
        motor = MultiMotorDummy('x', 'y')
        motor.set(x=1, y=2)
        time.sleep(1)
        motor.stop()
        val1 = motor.get()
        self.assertTrue(all(v < t for v, t in zip(val1.values(), [1, 2])))
        self.assertFalse(any(motor.isBusy.values()))
        time.sleep(0.1)
        val2 = motor.get()
        self.assertFalse(any(motor.isBusy.values()))
        self.assertEqual(val1, val2)


    def test_waitForReady_get(self):
        """
        Tests set with waitForReady enabled.

        Sets target values with wait=True and checks that interactions such as get are blocked until the motion finishes.
        """
        motor = MultiMotorDummy('x', 'y')
        motor.set(x=1, y=2, wait=True)
        val = motor.get()
        self.assertTrue(all(v == t for v, t in zip(val.values(), [1, 2])))
        self.assertFalse(any(motor.isBusy.values()))


    def test_waitForReady_set(self):
        """
        Tests set with waitForReady enabled.

        Sets target values with wait=True and checks that interactions such as set are blocked until the motion finishes.
        """
        motor = MultiMotorDummy('x', 'y')
        motor.set(x=1, y=2, wait=True)
        motor.set(x=2, y=3)
        val = motor.get()
        self.assertTrue(all(v > t for v, t in zip(val.values(), [1, 2])))


    def test_waitForReady_stop(self):
        """
        Tests set and stop methods with waitForReady (stop during motion).

        Sets target values with wait=True and checks that interactions such as stop are blocked until the motion finishes.
        """
        motor = MultiMotorDummy('x', 'y')
        motor.set(x=1, y=2, wait=True)
        val = motor.get()
        motor.stop()
        self.assertTrue(all(v == t for v, t in zip(val.values(), [1, 2])))
        

    def test_isAlive_deadResume(self):
        """
        Tests the isAlive property with per-axis error simulation and recovery.

        Simulates an axis going dead by setting the error flag, verifies the alive state and returned value.
        Then recovers the axis, and checks that the alive state and returned value are correct.
        """
        motor = MultiMotorDummy('x', 'y')
        motor.set(x=1, y=2)
        time.sleep(0.1)
        motor._error[0] = True
        self.assertEqual([motor.isAlive['x'], motor.isAlive['y']], [False, True])
        motor._error[0] = False
        self.assertEqual([motor.isAlive['x'], motor.isAlive['y']], [True, True])
        time.sleep(2/motor._speed)
        val = motor.get()
        self.assertTrue(all(v == t for v, t in zip(val.values(), [1, 2])))



    def test_lock(self):
        """
        Tests the lock functionality.

        Simulates a slowly responding motor by adding a sleep inside set(), before the motor motion begins.
        The actual motion is performed by calling the _set() method.
        Verifies that the _loadState() method is blocked by the lock, and that the busy state is set right after set() is called, even before the motor starts moving.
        """
        slowMotor = SlowMultiMotorDummy('x', 'y')
        slowMotor.set(x=1, y=2)
        self.assertTrue(any(slowMotor.isBusy.values()))


class SlowMultiMotorDummy(MultiMotorDummy):
    def set(self, wait=False, waitInterval=0.1, **kwargs):
        with QtCore.QMutexLocker(self._mutex):
            time.sleep(1)

            # Validate axis names
            invalid = [name for name in kwargs if name not in self._info]
            if invalid:
                raise ValueError(f"Axis name(s) {invalid} not recognized. Available axes: {self.nameList}")

            # Update busy state for each axis in kwargs and emit busy state only for axes that are now busy
            for name, value in kwargs.items():
                self._info[name].busy = not np.isnan(value)
            self.busyStateChanged.emit({name: True for name in kwargs if self._info[name].busy})

            # Set actual values for the axes in kwargs
            self._set(kwargs)

        if wait:
            self.waitForReady(waitInterval)