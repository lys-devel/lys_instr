"""
Test suite for `SingleMotorGUI` using `SingleMotorDummy` as a simulated motor device.

Uses `qtbot` to simulate user interactions with the GUI control panel.
Tests verify correct behavior of both the GUI and the motor object by checking display elements, setting spin box values, clicking buttons, etc.
"""

import pytest
from lys_instr.GUI.MultiMotorGUI import MultiMotorGUI, MultiMotorFeatures
from lys_instr.dummy.MultiMotorDummy import MultiMotorDummy
from lys.Qt import QtWidgets, QtCore


@pytest.fixture
def gui(qtbot):
    """
    Fixture that provides a `SingleMotorGUI` instance connected to a simulated `SingleMotorDummy` motor.

    Args:
        qtbot (pytest-qt.QtBot): The qtbot fixture for simulating user interaction.

    Returns:
        SingleMotorGUI: The GUI widget under test.
    """
    dummy = MultiMotorDummy()
    widget = MultiMotorGUI(dummy, 'Test MultiMotorGUI')
    qtbot.addWidget(widget)
    return widget


def findWidgetByText(gui, text):
    """
    Finds a child widget of the given GUI widget whose text matches the specified value.

    Args:
        gui (QWidget): The parent widget to search.
        text (str): The text to match.

    Returns:
        QWidget or None: The found widget, or None if not found.
    """
    for cls in (QtWidgets.QLabel, QtWidgets.QPushButton):
        for wdgt in gui.findChildren(cls):
            if wdgt.text() == text:
                return wdgt
    return None


def findWidgetByToolTip(gui, text):
    """
    Finds a child widget of the given GUI widget whose tooltip text matches the specified value.

    Args:
        gui (QWidget): The parent widget to search.
        text (str): The tooltip text to match.

    Returns:
        QWidget or None: The found widget, or None if not found.
    """
    for wdgt in gui.findChildren(QtWidgets.QWidget):
        if wdgt.toolTip() == text:
            return wdgt
    return None


def findWidgetBelowText(gui, text, widgetType):
    """
    Finds a widget of the specified type located directly below a label with the given text in the GUI's grid layout.

    Args:
        gui (QWidget): The parent widget to search.
        text (str): The label text to match.
        widgetType (type): The type of widget to find.

    Returns:
        QWidget or None: The found widget, or None if not found.
    """
    layout = gui.layout()
    for lbl in gui.findChildren(QtWidgets.QWidget):
        if lbl.text() == text:
            row, col = findWidgetPosition(layout, lbl)
            if row is not None:
                lowerItem = layout.itemAtPosition(row + 1, col)
                if lowerItem:
                    if isinstance(lowerItem.widget(), widgetType):
                        return lowerItem.widget()
    return None


def findWidgetPosition(layout, widget):
    """
    Finds the (row, column) position of a widget in a QGridLayout.

    Args:
        layout (QGridLayout): The layout to search.
        widget (QWidget): The widget to locate.

    Returns:
        tuple: (row, column) if found, otherwise (None, None).
    """
    for row in range(layout.rowCount()):
        for col in range(layout.columnCount()):
            item = layout.itemAtPosition(row, col)
            if item and item.widget() is widget:
                return row, col
    return None, None


def test_findWidgets(gui):
    """
    Confirms that all key widgets, including buttons, spin boxes, indicators, can be found in the GUI.
    """
    goPushButton = findWidgetByText(gui, 'Go')
    assert goPushButton is not None, 'Go push-button not found'

    stopPushButton = findWidgetByText(gui, 'Stop')
    assert stopPushButton is not None, 'Stop push-button not found'

    axisNamesAll = ['x', 'y', 'z', 'α', 'β', 'γ']
    axisNamesSettable=["z", "α", "y"]
    axisNamesJoggable=["z"]
    axisNamesOffsettable=["y", "z"]

    axisLabel = {}
    nowAtSpinBox = {}
    moveToSpinBox = {}
    jogNegaBtn = {}
    jogPosiBtn = {}
    jogStepSpinBox = {}

    name = 'x'
    lbl = findWidgetByText(gui, name)
    axisLabel[name] = lbl
    row, col = findWidgetPosition(gui.layout(), lbl)
    # print(row, col)
    nowAtSpinBox[name] = gui.layout().itemAtPosition(row, 1)


    # for name in axisNamesAll:
    #     lbl = findWidgetByText(gui, name)
    #     axisLabel[name] = lbl
    #     row, col = findWidgetPosition(gui.layout(), lbl)
    #     # print(row, col)
    #     nowAtSpinBox[name] = gui.layout().itemAtPosition(1, col)
        # moveToSpinBox[name] = gui.layout().itemAtPosition(row + 2, col)
        # jogNegaBtn[name] = gui.layout().itemAtPosition(row + 3, col)
        # jogPosiBtn[name] = gui.layout().itemAtPosition(row + 4, col)
        # jogStepSpinBox[name] = gui.layout().itemAtPosition(row + 5, col)



















    # assert nowAtSpinBox is not None, f'Now at spin-box for axis {name} not found'
        # assert lbl is not None, f'Label for axis {name} not found'




    # moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
    # assert moveToSpinBox is not None, 'Move to spin-box not found'

    # settingsPushButton = findWidgetByToolTip(gui, 'Settings')
    # assert settingsPushButton is not None, 'Settings push-button not found'

    # aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')
    # assert aliveIndicator is not None, 'Alive/dead indicator not found'


# def nowAtStatic(qtbot, nowAtSpinBox):
#     """
#     Checks if the value of the 'Now at' spin box remains static over a short period.

#     Args:
#         qtbot (pytest-qt.QtBot): The qtbot fixture for simulating user interaction.
#         nowAtSpinBox (QAbstractSpinBox): The spin box to check.

#     Returns:
#         bool: True if the value is static, False otherwise.
#     """
#     last = nowAtSpinBox.value()
#     qtbot.wait(200)
#     return nowAtSpinBox.value() == last


# def readyStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue):
#     """
#     Asserts that the GUI reflects the ready state before motion starts.

#     Args:
#         nowAtSpinBox (QAbstractSpinBox): The 'Now at' spin box.
#         moveToSpinBox (QAbstractSpinBox): The 'Move to' spin box.
#         goPushButton (QPushButton): The 'Go' button.
#         stopPushButton (QPushButton): The 'Stop' button.
#         aliveIndicator (QLabel): The alive/dead indicator.
#         initialValue (float): The initial position value.
#         targetValue (float): The target position value.
#     """
#     assert moveToSpinBox.value() == targetValue, 'readyStateChecks: Move to spin-box value mismatch'
#     assert nowAtSpinBox.value() == initialValue, 'readyStateChecks: Now at spin-box value mismatch'
#     assert aliveIndicator.text() == 'Alive', 'readyStateChecks: Alive indicator text mismatch'
#     assert goPushButton.text() == 'Go', 'readyStateChecks: Go push-button text mismatch'
#     assert goPushButton.isEnabled(), 'readyStateChecks: Go push-button should be enabled'
#     assert stopPushButton.text() == 'Stop', 'readyStateChecks: Stop push-button text mismatch'
#     assert not stopPushButton.isEnabled(), 'readyStateChecks: Stop push-button should not be enabled'


# def deadStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue):
#     """
#     Asserts that the GUI reflects the dead state of the motor.

#     Args:
#         nowAtSpinBox (QAbstractSpinBox): The 'Now at' spin box.
#         moveToSpinBox (QAbstractSpinBox): The 'Move to' spin box.
#         goPushButton (QPushButton): The 'Go' button.
#         stopPushButton (QPushButton): The 'Stop' button.
#         aliveIndicator (QLabel): The alive/dead indicator.
#         initialValue (float): The initial position value.
#         targetValue (float): The target position value.
#     """
#     assert moveToSpinBox.value() == targetValue, 'deadStateChecks: Move to spin-box value mismatch'
#     assert initialValue < nowAtSpinBox.value() < targetValue, 'deadStateChecks: Now at spin-box value mismatch'
#     assert aliveIndicator.text() == 'Dead', 'deadStateChecks: Alive indicator text mismatch'
#     assert goPushButton.text() == 'Moving', 'deadStateChecks: Go push-button text mismatch'
#     assert not goPushButton.isEnabled(), 'deadStateChecks: Go push-button should not be enabled'
#     assert stopPushButton.text() == 'Stop', 'deadStateChecks: Stop push-button text mismatch'
#     assert not stopPushButton.isEnabled(), 'deadStateChecks: Stop push-button should not be enabled'


# def movingStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue):
#     """
#     Asserts that the GUI reflects the moving state of the motor.

#     Args:
#         qtbot (pytest-qt.QtBot): The qtbot fixture for simulating user interaction.
#         nowAtSpinBox (QAbstractSpinBox): The 'Now at' spin box.
#         moveToSpinBox (QAbstractSpinBox): The 'Move to' spin box.
#         goPushButton (QPushButton): The 'Go' button.
#         stopPushButton (QPushButton): The 'Stop' button.
#         aliveIndicator (QLabel): The alive/dead indicator.
#         initialValue (float): The initial position value.
#         targetValue (float): The target position value.
#     """
#     assert not nowAtStatic(qtbot, nowAtSpinBox)
#     assert moveToSpinBox.value() == targetValue, 'movingStateChecks: Move to spin-box value mismatch'
#     assert initialValue < nowAtSpinBox.value() < targetValue, 'movingStateChecks: Now at spin-box value mismatch'
#     assert aliveIndicator.text() == 'Alive', 'movingStateChecks: Alive indicator text mismatch'
#     assert goPushButton.text() == 'Moving', 'movingStateChecks: Go push-button text mismatch'
#     assert not goPushButton.isEnabled(), 'movingStateChecks: Go push-button should not be enabled'
#     assert stopPushButton.text() == 'Stop', 'movingStateChecks: Stop push-button text mismatch'
#     assert stopPushButton.isEnabled(), 'movingStateChecks: Stop push-button should be enabled'


# def finishedStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, targetValue):
#     """
#     Asserts that the GUI reflects the finished state after motion completes.

#     Args:
#         nowAtSpinBox (QAbstractSpinBox): The 'Now at' spin box.
#         moveToSpinBox (QAbstractSpinBox): The 'Move to' spin box.
#         goPushButton (QPushButton): The 'Go' button.
#         stopPushButton (QPushButton): The 'Stop' button.
#         aliveIndicator (QLabel): The alive/dead indicator.
#         targetValue (float): The target position value.
#     """
#     assert nowAtStatic(qtbot, nowAtSpinBox)
#     assert moveToSpinBox.value() == targetValue, 'finishedStateChecks: Move to spin-box value mismatch'
#     assert pytest.approx(nowAtSpinBox.value(), 0.001) == targetValue, 'finishedStateChecks: Now at spin-box value mismatch'
#     assert aliveIndicator.text() == 'Alive', 'finishedStateChecks: Alive indicator text mismatch'
#     assert goPushButton.text() == 'Go', 'finishedStateChecks: Go push-button text mismatch'
#     assert goPushButton.isEnabled(), 'finishedStateChecks: Go push-button should be enabled'
#     assert stopPushButton.text() == 'Stop', 'finishedStateChecks: Stop push-button text mismatch'
#     assert not stopPushButton.isEnabled(), 'finishedStateChecks: Stop push-button should not be enabled'


# def stoppedStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue):
#     """
#     Asserts that the GUI reflects the stopped state after user interruption.

#     Args:
#         qtbot (pytest-qt.QtBot): The qtbot fixture for simulating user interaction.
#         nowAtSpinBox (QAbstractSpinBox): The 'Now at' spin box.
#         moveToSpinBox (QAbstractSpinBox): The 'Move to' spin box.
#         goPushButton (QPushButton): The 'Go' button.
#         stopPushButton (QPushButton): The 'Stop' button.
#         aliveIndicator (QLabel): The alive/dead indicator.
#         initialValue (float): The initial position value.
#         targetValue (float): The target position value.
#     """
#     assert nowAtStatic(qtbot, nowAtSpinBox), 'stoppedStateChecks: Now at spin-box should be static'
#     assert moveToSpinBox.value() == targetValue, 'stoppedStateChecks: Move to spin-box value mismatch'
#     assert initialValue < nowAtSpinBox.value() < targetValue, 'stoppedStateChecks: Now at spin-box value mismatch'
#     assert aliveIndicator.text() == 'Alive', 'stoppedStateChecks: Alive indicator text mismatch'
#     assert goPushButton.text() == 'Go', 'stoppedStateChecks: Go push-button text mismatch'
#     assert goPushButton.isEnabled(), 'stoppedStateChecks: Go push-button should be enabled'
#     assert stopPushButton.text() == 'Stop', 'stoppedStateChecks: Stop push-button text mismatch'
#     assert not stopPushButton.isEnabled(), 'stoppedStateChecks: Stop push-button should not be enabled'


# def test_initialDisplay(gui):
#     """
#     Checks the initial display of the GUI.
#     """
#     goPushButton = findWidgetByText(gui, 'Go')
#     stopPushButton = findWidgetByText(gui, 'Stop')
#     nowAtSpinBox = findWidgetBelowText(gui, 'Now at', QtWidgets.QAbstractSpinBox)
#     moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
#     aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')

#     targetValue = 0
#     initialValue = 0
#     readyStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)


# def test_go(qtbot, gui):
#     """
#     Simulates setting a target value and pressing the 'Go' button, then verifies that the GUI displays the expected information of the simulated motor throughout the operation. 
#     """
#     goPushButton = findWidgetByText(gui, 'Go')
#     stopPushButton = findWidgetByText(gui, 'Stop')
#     nowAtSpinBox = findWidgetBelowText(gui, 'Now at', QtWidgets.QAbstractSpinBox)
#     moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
#     aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')

#     targetValue = 5
#     initialValue = nowAtSpinBox.value()

#     moveToSpinBox.setValue(targetValue)
#     qtbot.waitUntil(lambda: moveToSpinBox.value() != initialValue, timeout=1000) # Unit: ms
#     readyStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)

#     qtbot.mouseClick(goPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: nowAtSpinBox.value() != initialValue, timeout=1000) # Unit: ms
#     movingStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)

#     qtbot.waitUntil(lambda: nowAtSpinBox.value() == targetValue, timeout=5000) # Unit: ms; should be longer than gui._obj._duration
#     finishedStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, targetValue)


# def test_stop_resume(qtbot, gui):
#     """
#     Checks that, after starting the motor motion, pressing 'Stop' halts the movement and that pressing 'Go' again resumes the motion as expected.
#     """
#     goPushButton = findWidgetByText(gui, 'Go')
#     stopPushButton = findWidgetByText(gui, 'Stop')
#     nowAtSpinBox = findWidgetBelowText(gui, 'Now at', QtWidgets.QAbstractSpinBox)
#     moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
#     aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')

#     targetValue = 5
#     initialValue = nowAtSpinBox.value()

#     moveToSpinBox.setValue(targetValue)
#     qtbot.waitUntil(lambda: moveToSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     qtbot.mouseClick(goPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: nowAtSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     qtbot.mouseClick(stopPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: goPushButton.isEnabled(), timeout=1000)
#     stoppedStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)

#     lastValue = nowAtSpinBox.value()
#     qtbot.mouseClick(goPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: nowAtSpinBox.value() != lastValue, timeout=1000) # Unit: ms
#     movingStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)

#     qtbot.waitUntil(lambda: nowAtSpinBox.value() == targetValue, timeout=5000) # Unit: ms; should be longer than gui._obj._duration
#     finishedStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, targetValue)


# def test_settingsDialog(qtbot, gui):
#     """
#     Simulates pressing the settings button, checks that the dialog opens, and verifies the presence and correct display of the change button and alive state line-edit.
#     """
#     settingsPushButton = findWidgetByToolTip(gui, 'Settings')
    
#     qtbot.mouseClick(settingsPushButton, QtCore.Qt.LeftButton)
#     for tlw in QtWidgets.QApplication.topLevelWidgets():
#         if isinstance(tlw, QtWidgets.QDialog) and tlw.isVisible():
#             dialog = tlw
#             break
#     assert dialog, 'Settings dialog did not open'

#     qtbot.addWidget(dialog)
#     changePushButton = dialog.findChild(QtWidgets.QPushButton)
#     aliveLine = dialog.findChild(QtWidgets.QLineEdit)

#     assert changePushButton, 'Change push-button not found'
#     assert aliveLine, 'Alive state line-edit not found'
#     assert aliveLine.text() in ('Alive', 'Dead'), 'Alive state text incorrect'


# def test_dead_resume(qtbot, gui):
#     """
#     Simulates disconnection by raising a TimeoutError from the dummy motor, and checks that the motor enters the dead state.
#     Then verify that the motor recovers by reconnecting through the settings dialog ('Change' button) and returns to the alive state.
#     """

#     goPushButton = findWidgetByText(gui, 'Go')
#     stopPushButton = findWidgetByText(gui, 'Stop')
#     nowAtSpinBox = findWidgetBelowText(gui, 'Now at', QtWidgets.QAbstractSpinBox)
#     moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
#     aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')

#     targetValue = 5
#     initialValue = nowAtSpinBox.value()

#     moveToSpinBox.setValue(targetValue)
#     qtbot.waitUntil(lambda: moveToSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     qtbot.mouseClick(goPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: nowAtSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     # with patch.object(gui._obj, '_get', side_effect=TimeoutError):
#     #     qtbot.waitUntil(lambda: aliveIndicator.text() == 'Dead', timeout=1000)
#     #     deadStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)
#     gui._obj._error = True
#     qtbot.waitUntil(lambda: aliveIndicator.text() == 'Dead', timeout=1000)
#     deadStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)


#     gui._obj._error = False
#     assert not nowAtStatic(qtbot, nowAtSpinBox), 'Now at spin-box should keep reading real values which is not static'
#     deadStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)   # Without manually resuming it, the dead state should remain while keeping trying to update now at values
    
#     settingsPushButton = findWidgetByToolTip(gui, 'Settings')
#     qtbot.mouseClick(settingsPushButton, QtCore.Qt.LeftButton)
#     for tlw in QtWidgets.QApplication.topLevelWidgets():
#         if isinstance(tlw, QtWidgets.QDialog) and tlw.isVisible():
#             dialog = tlw
#             break
#     qtbot.addWidget(dialog)
#     changePushButton = dialog.findChild(QtWidgets.QPushButton)  # Or: changePushButton = findWidgetByText(dialog, 'Change')
#     aliveLine = dialog.findChild(QtWidgets.QLineEdit)           # Or: aliveLine = findWidgetByText(dialog, 'Alive') or findWidgetByText(dialog, 'Dead')
#     assert aliveLine.text() == 'Dead', 'Alive state should be Dead in the dialog after toggling to Dead'

#     qtbot.mouseClick(changePushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: aliveLine.text() == 'Alive', timeout=1000)
#     assert aliveLine.text() == 'Alive', 'Alive state should be Alive in the dialog after toggling to Alive'
#     movingStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)


# def test_toggleAlive_whileMoving(qtbot, gui):
#     """
#     Simulates opening the settings dialog during motion, toggling the alive/dead state, and verifies that the GUI and motor reflect the correct state transitions throughout the operation.
#     """
#     goPushButton = findWidgetByText(gui, 'Go')
#     stopPushButton = findWidgetByText(gui, 'Stop')
#     nowAtSpinBox = findWidgetBelowText(gui, 'Now at', QtWidgets.QAbstractSpinBox)
#     moveToSpinBox = findWidgetBelowText(gui, 'Move to', QtWidgets.QAbstractSpinBox)
#     aliveIndicator = findWidgetByText(gui, 'Alive') or findWidgetByText(gui, 'Dead')

#     targetValue = 5
#     initialValue = nowAtSpinBox.value()

#     moveToSpinBox.setValue(targetValue)
#     qtbot.waitUntil(lambda: moveToSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     qtbot.mouseClick(goPushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: nowAtSpinBox.value() != initialValue, timeout=1000) # Unit: ms

#     settingsPushButton = findWidgetByToolTip(gui, 'Settings')
#     qtbot.mouseClick(settingsPushButton, QtCore.Qt.LeftButton)

#     for tlw in QtWidgets.QApplication.topLevelWidgets():
#         if isinstance(tlw, QtWidgets.QDialog) and tlw.isVisible():
#             dialog = tlw
#             break
#     assert dialog, 'Settings dialog did not open'

#     qtbot.addWidget(dialog)
#     changePushButton = dialog.findChild(QtWidgets.QPushButton)
#     aliveLine = dialog.findChild(QtWidgets.QLineEdit)
#     assert aliveLine.text() == 'Alive', 'Alive state should be Alive in the dialog before toggling'

#     qtbot.mouseClick(changePushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: aliveLine.text() == 'Dead', timeout=1000)
#     assert aliveLine.text() == 'Dead', 'Alive state should be Dead in the dialog after toggling to Dead'
#     deadStateChecks(nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)

#     qtbot.mouseClick(changePushButton, QtCore.Qt.LeftButton)
#     qtbot.waitUntil(lambda: aliveLine.text() == 'Alive', timeout=1000)
#     assert aliveLine.text() == 'Alive', 'Alive state should be Alive in the dialog after toggling back to Alive'
#     movingStateChecks(qtbot, nowAtSpinBox, moveToSpinBox, goPushButton, stopPushButton, aliveIndicator, initialValue, targetValue)




